// Prisma Schema for Teddybrew (Hive Community MVP)
// Database: Neon Postgres with connection pooling

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// User Model - Auth.js compatible
model User {
  id            String    @id @default(cuid())
  name          String?   // Display name (public)
  username      String?   @unique
  email         String    @unique
  emailVerified DateTime?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Private profile fields (for mail merge, internal use)
  firstName     String?   @db.VarChar(50)
  lastName      String?   @db.VarChar(50)

  // Public profile fields
  bio           String?   @db.VarChar(500)
  interests     String?   @db.VarChar(500)
  communityHope String?   @db.VarChar(500)
  isPublic      Boolean   @default(true)

  // Granular privacy controls for profile sections
  showUpcomingEvents Boolean @default(true)
  showPastEvents     Boolean @default(false)  // Default false - opt-in for event history
  showCommunities    Boolean @default(true)

  // Email preferences
  emailEventReminders Boolean @default(true)

  // Relations
  accounts          Account[]
  sessions          Session[]
  ownedCommunities  Community[]   @relation("CommunityOwner")
  memberships       Member[]
  organizedEvents   Event[]       @relation("EventOrganizer")
  coOrganizedEvents Event[]       @relation("EventCoOrganizers")
  rsvps             RSVP[]

  // Chat & Forum relations
  messages          Message[]     @relation("MessageAuthor")
  deletedMessages   Message[]     @relation("MessageDeletedBy")
  messageReactions  MessageReaction[]
  posts             Post[]        @relation("PostAuthor")
  deletedPosts      Post[]        @relation("PostDeletedBy")
  comments          Comment[]     @relation("CommentAuthor")
  deletedComments   Comment[]     @relation("CommentDeletedBy")
  postVotes         PostVote[]
  commentVotes      CommentVote[]

  // Notifications
  notifications     Notification[]

  // Invitations created by this user
  createdInvites    CommunityInvite[] @relation("InviteCreator")

  // Event reminders
  eventRemindersSent EventReminderSent[]

  @@index([email])
  @@index([username])
}

// Auth.js Account Model
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

// Auth.js Session Model
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Auth.js Verification Token Model
model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Community Model
model Community {
  id          String   @id @default(cuid())
  // slug is immutable after creation - used in URLs
  slug        String   @unique
  name        String
  description String?
  type        CommunityType @default(PUBLIC)
  ownerId     String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Activity tracking for sorting/filtering
  lastActivityAt DateTime @default(now())

  // Relations
  owner        User              @relation("CommunityOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  members      Member[]
  events       Event[]
  chatChannels ChatChannel[]
  posts        Post[]
  invites      CommunityInvite[]

  @@index([slug])
  @@index([ownerId])
  @@index([type])
  @@index([lastActivityAt])
}

// Community Type Enum
enum CommunityType {
  PUBLIC
  PRIVATE
}

// Member Model - Join table for User <-> Community
model Member {
  id          String     @id @default(cuid())
  userId      String
  communityId String
  role        MemberRole @default(MEMBER)
  joinedAt    DateTime   @default(now())

  // Relations
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  community Community @relation(fields: [communityId], references: [id], onDelete: Cascade)

  @@unique([userId, communityId])
  @@index([userId])
  @@index([communityId])
  @@index([role])
}

// Member Role Enum (ONLY owner and member - no admin per MVP spec)
enum MemberRole {
  OWNER
  MEMBER
}

// Community Invitation - for private community invites
model CommunityInvite {
  id          String   @id @default(cuid())
  communityId String
  email       String
  token       String   @unique @default(cuid())
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  createdById String

  community Community @relation(fields: [communityId], references: [id], onDelete: Cascade)
  createdBy User      @relation("InviteCreator", fields: [createdById], references: [id])

  @@unique([communityId, email])
  @@index([token])
  @@index([email])
}

// Event Model
model Event {
  id          String    @id @default(cuid())
  title       String
  description String?
  location    String?   // Default location (sessions can override)
  capacity    Int?      // Default capacity (sessions can override)
  communityId String
  organizerId String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Virtual event fields
  isVirtual     Boolean  @default(false)
  meetingUrl    String?  @db.VarChar(500)
  chatChannelId String?  @unique

  // Relations
  community    Community      @relation(fields: [communityId], references: [id], onDelete: Cascade)
  organizer    User           @relation("EventOrganizer", fields: [organizerId], references: [id], onDelete: Cascade)
  coOrganizers User[]         @relation("EventCoOrganizers")
  sessions     EventSession[] // Every event has 1+ sessions
  chatChannel  ChatChannel?   @relation(fields: [chatChannelId], references: [id], onDelete: SetNull)

  @@index([communityId])
  @@index([organizerId])
}

// Event Session - Each event has one or more sessions
model EventSession {
  id        String    @id @default(cuid())
  eventId   String
  title     String?   // Optional: "Day 1", "Morning Session", etc.
  startTime DateTime
  endTime   DateTime?
  location  String?   // Override event location (optional)
  capacity  Int?      // Override event capacity (optional)
  createdAt DateTime  @default(now())

  event Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  rsvps RSVP[]
  remindersSent EventReminderSent[]

  @@index([eventId])
  @@index([startTime])
}

// RSVP Model - Links to Session (not Event directly)
model RSVP {
  id        String     @id @default(cuid())
  userId    String
  sessionId String
  status    RSVPStatus @default(GOING)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  // Relations
  user    User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  session EventSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([userId, sessionId])
  @@index([userId])
  @@index([sessionId])
  @@index([status])
}

// RSVP Status Enum
enum RSVPStatus {
  GOING
  NOT_GOING
}

// ============ CHAT SYSTEM ============

// Chat Channel - Multiple channels per community (like Discord)
model ChatChannel {
  id          String   @id @default(cuid())
  name        String   @db.VarChar(100)
  description String?  @db.VarChar(500)
  communityId String
  isDefault   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Event channel link (null for regular channels)
  event Event?

  community Community @relation(fields: [communityId], references: [id], onDelete: Cascade)
  messages  Message[]

  @@unique([communityId, name])
  @@index([communityId])
}

// Chat Message
model Message {
  id          String    @id @default(cuid())
  content     String    @db.Text
  channelId   String
  authorId    String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?
  deletedById String?

  // Reply support (single-level threading)
  replyToId String?
  replyTo   Message?  @relation("MessageReplies", fields: [replyToId], references: [id], onDelete: SetNull)
  replies   Message[] @relation("MessageReplies")

  channel   ChatChannel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  author    User        @relation("MessageAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  deletedBy User?       @relation("MessageDeletedBy", fields: [deletedById], references: [id])

  // Reactions
  reactions MessageReaction[]

  @@index([channelId, createdAt(sort: Desc)])
  @@index([authorId])
  @@index([replyToId])
}

// Message Reaction - emoji reactions on chat messages
model MessageReaction {
  id        String   @id @default(cuid())
  messageId String
  userId    String
  emoji     String   @db.VarChar(10) // e.g., "thumbsup", "heart"
  createdAt DateTime @default(now())

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId, emoji]) // One per emoji per user per message
  @@index([messageId])
}

// ============ FORUM SYSTEM ============

model Post {
  id           String    @id @default(cuid())
  title        String    @db.VarChar(300)
  content      String    @db.Text
  communityId  String
  authorId     String
  isPinned     Boolean   @default(false)
  voteScore    Int       @default(0)
  commentCount Int       @default(0)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  deletedAt    DateTime?
  deletedById  String?

  community   Community  @relation(fields: [communityId], references: [id], onDelete: Cascade)
  author      User       @relation("PostAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  deletedBy   User?      @relation("PostDeletedBy", fields: [deletedById], references: [id])
  comments    Comment[]
  votes       PostVote[]

  @@index([communityId, createdAt(sort: Desc)])
  @@index([communityId, voteScore(sort: Desc)])
  @@index([communityId, isPinned, createdAt(sort: Desc)])
  @@index([authorId])
}

model Comment {
  id          String    @id @default(cuid())
  content     String    @db.Text
  postId      String
  authorId    String
  parentId    String?
  depth       Int       @default(0)
  voteScore   Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?
  deletedById String?

  post      Post          @relation(fields: [postId], references: [id], onDelete: Cascade)
  author    User          @relation("CommentAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  deletedBy User?         @relation("CommentDeletedBy", fields: [deletedById], references: [id])
  parent    Comment?      @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   Comment[]     @relation("CommentReplies")
  votes     CommentVote[]

  @@index([postId, createdAt])
  @@index([postId, voteScore(sort: Desc)])
  @@index([parentId])
  @@index([authorId])
}

model PostVote {
  id        String   @id @default(cuid())
  postId    String
  userId    String
  value     Int
  createdAt DateTime @default(now())

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@index([postId])
}

model CommentVote {
  id        String   @id @default(cuid())
  commentId String
  userId    String
  value     Int
  createdAt DateTime @default(now())

  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([commentId, userId])
  @@index([commentId])
}

// ============ NOTIFICATION SYSTEM ============

enum NotificationType {
  COMMENT_REPLY    // Someone replied to your comment
  POST_COMMENT     // Someone commented on your post
  POST_VOTE        // Your post received significant votes
  EVENT_REMINDER   // Upcoming event reminder
  NEW_MEMBER       // Someone joined your community (owner only)
  COMMUNITY_INVITE // You've been invited to a community
}

model Notification {
  id        String           @id @default(cuid())
  type      NotificationType
  userId    String           // Recipient
  title     String           @db.VarChar(255)
  message   String?          @db.Text
  link      String?          @db.VarChar(500) // URL to navigate to
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead, createdAt(sort: Desc)])
  @@index([userId, createdAt(sort: Desc)])
}

// ============ EMAIL TRACKING ============

// Track sent event reminders for idempotency
model EventReminderSent {
  id            String   @id @default(cuid())
  sessionId     String
  userId        String
  resendEmailId String?  // Store Resend scheduled email ID for cancellation
  sentAt        DateTime @default(now())

  session EventSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user    User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([sessionId, userId])
  @@index([sessionId])
  @@index([resendEmailId])
}
