// Prisma Schema for Teddybrew (Hive Community MVP)
// Database: Neon Postgres with connection pooling

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// User Model - Auth.js compatible
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  accounts      Account[]
  sessions      Session[]
  ownedCommunities Community[]  @relation("CommunityOwner")
  memberships   Member[]
  organizedEvents Event[]      @relation("EventOrganizer")
  coOrganizedEvents Event[]    @relation("EventCoOrganizers")
  rsvps         RSVP[]

  @@index([email])
}

// Auth.js Account Model
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

// Auth.js Session Model
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Auth.js Verification Token Model
model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Community Model
model Community {
  id          String   @id @default(cuid())
  // slug is immutable after creation - used in URLs
  slug        String   @unique
  name        String
  description String?
  type        CommunityType @default(PUBLIC)
  ownerId     String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  owner   User     @relation("CommunityOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  members Member[]
  events  Event[]

  @@index([slug])
  @@index([ownerId])
  @@index([type])
}

// Community Type Enum
enum CommunityType {
  PUBLIC
  PRIVATE
}

// Member Model - Join table for User <-> Community
model Member {
  id          String     @id @default(cuid())
  userId      String
  communityId String
  role        MemberRole @default(MEMBER)
  joinedAt    DateTime   @default(now())

  // Relations
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  community Community @relation(fields: [communityId], references: [id], onDelete: Cascade)

  @@unique([userId, communityId])
  @@index([userId])
  @@index([communityId])
  @@index([role])
}

// Member Role Enum (ONLY owner and member - no admin per MVP spec)
enum MemberRole {
  OWNER
  MEMBER
}

// Event Model
model Event {
  id          String    @id @default(cuid())
  title       String
  description String?
  startTime   DateTime
  endTime     DateTime?
  location    String?
  capacity    Int?      // null = unlimited
  communityId String
  organizerId String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  community    Community @relation(fields: [communityId], references: [id], onDelete: Cascade)
  organizer    User      @relation("EventOrganizer", fields: [organizerId], references: [id], onDelete: Cascade)
  coOrganizers User[]    @relation("EventCoOrganizers")
  rsvps        RSVP[]

  @@index([communityId])
  @@index([organizerId])
  @@index([startTime])
}

// RSVP Model
model RSVP {
  id        String     @id @default(cuid())
  userId    String
  eventId   String
  status    RSVPStatus @default(GOING)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  // Relations
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId])
  @@index([userId])
  @@index([eventId])
  @@index([status])
}

// RSVP Status Enum
enum RSVPStatus {
  GOING
  NOT_GOING
}
