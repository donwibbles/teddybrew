// Prisma Schema for Teddybrew (Hive Community MVP)
// Database: Neon Postgres with connection pooling

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// User Model - Auth.js compatible
model User {
  id            String    @id @default(cuid())
  name          String?
  username      String?   @unique
  email         String    @unique
  emailVerified DateTime?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  accounts          Account[]
  sessions          Session[]
  ownedCommunities  Community[]   @relation("CommunityOwner")
  memberships       Member[]
  organizedEvents   Event[]       @relation("EventOrganizer")
  coOrganizedEvents Event[]       @relation("EventCoOrganizers")
  rsvps             RSVP[]

  // Chat & Forum relations
  messages          Message[]     @relation("MessageAuthor")
  deletedMessages   Message[]     @relation("MessageDeletedBy")
  posts             Post[]        @relation("PostAuthor")
  deletedPosts      Post[]        @relation("PostDeletedBy")
  comments          Comment[]     @relation("CommentAuthor")
  deletedComments   Comment[]     @relation("CommentDeletedBy")
  postVotes         PostVote[]
  commentVotes      CommentVote[]

  // Notifications
  notifications     Notification[]

  @@index([email])
  @@index([username])
}

// Auth.js Account Model
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

// Auth.js Session Model
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Auth.js Verification Token Model
model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Community Model
model Community {
  id          String   @id @default(cuid())
  // slug is immutable after creation - used in URLs
  slug        String   @unique
  name        String
  description String?
  type        CommunityType @default(PUBLIC)
  ownerId     String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  owner        User          @relation("CommunityOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  members      Member[]
  events       Event[]
  chatChannels ChatChannel[]
  posts        Post[]

  @@index([slug])
  @@index([ownerId])
  @@index([type])
}

// Community Type Enum
enum CommunityType {
  PUBLIC
  PRIVATE
}

// Member Model - Join table for User <-> Community
model Member {
  id          String     @id @default(cuid())
  userId      String
  communityId String
  role        MemberRole @default(MEMBER)
  joinedAt    DateTime   @default(now())

  // Relations
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  community Community @relation(fields: [communityId], references: [id], onDelete: Cascade)

  @@unique([userId, communityId])
  @@index([userId])
  @@index([communityId])
  @@index([role])
}

// Member Role Enum (ONLY owner and member - no admin per MVP spec)
enum MemberRole {
  OWNER
  MEMBER
}

// Event Model
model Event {
  id          String    @id @default(cuid())
  title       String
  description String?
  startTime   DateTime
  endTime     DateTime?
  location    String?
  capacity    Int?      // null = unlimited
  communityId String
  organizerId String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  community    Community @relation(fields: [communityId], references: [id], onDelete: Cascade)
  organizer    User      @relation("EventOrganizer", fields: [organizerId], references: [id], onDelete: Cascade)
  coOrganizers User[]    @relation("EventCoOrganizers")
  rsvps        RSVP[]

  @@index([communityId])
  @@index([organizerId])
  @@index([startTime])
}

// RSVP Model
model RSVP {
  id        String     @id @default(cuid())
  userId    String
  eventId   String
  status    RSVPStatus @default(GOING)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  // Relations
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId])
  @@index([userId])
  @@index([eventId])
  @@index([status])
}

// RSVP Status Enum
enum RSVPStatus {
  GOING
  NOT_GOING
}

// ============ CHAT SYSTEM ============

// Chat Channel - Multiple channels per community (like Discord)
model ChatChannel {
  id          String   @id @default(cuid())
  name        String   @db.VarChar(100)
  description String?  @db.VarChar(500)
  communityId String
  isDefault   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  community Community @relation(fields: [communityId], references: [id], onDelete: Cascade)
  messages  Message[]

  @@unique([communityId, name])
  @@index([communityId])
}

// Chat Message
model Message {
  id          String    @id @default(cuid())
  content     String    @db.Text
  channelId   String
  authorId    String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?
  deletedById String?

  channel   ChatChannel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  author    User        @relation("MessageAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  deletedBy User?       @relation("MessageDeletedBy", fields: [deletedById], references: [id])

  @@index([channelId, createdAt(sort: Desc)])
  @@index([authorId])
}

// ============ FORUM SYSTEM ============

model Post {
  id           String    @id @default(cuid())
  title        String    @db.VarChar(300)
  content      String    @db.Text
  communityId  String
  authorId     String
  isPinned     Boolean   @default(false)
  voteScore    Int       @default(0)
  commentCount Int       @default(0)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  deletedAt    DateTime?
  deletedById  String?

  community   Community  @relation(fields: [communityId], references: [id], onDelete: Cascade)
  author      User       @relation("PostAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  deletedBy   User?      @relation("PostDeletedBy", fields: [deletedById], references: [id])
  comments    Comment[]
  votes       PostVote[]

  @@index([communityId, createdAt(sort: Desc)])
  @@index([communityId, voteScore(sort: Desc)])
  @@index([communityId, isPinned, createdAt(sort: Desc)])
  @@index([authorId])
}

model Comment {
  id          String    @id @default(cuid())
  content     String    @db.Text
  postId      String
  authorId    String
  parentId    String?
  depth       Int       @default(0)
  voteScore   Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  deletedAt   DateTime?
  deletedById String?

  post      Post          @relation(fields: [postId], references: [id], onDelete: Cascade)
  author    User          @relation("CommentAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  deletedBy User?         @relation("CommentDeletedBy", fields: [deletedById], references: [id])
  parent    Comment?      @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   Comment[]     @relation("CommentReplies")
  votes     CommentVote[]

  @@index([postId, createdAt])
  @@index([postId, voteScore(sort: Desc)])
  @@index([parentId])
  @@index([authorId])
}

model PostVote {
  id        String   @id @default(cuid())
  postId    String
  userId    String
  value     Int
  createdAt DateTime @default(now())

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@index([postId])
}

model CommentVote {
  id        String   @id @default(cuid())
  commentId String
  userId    String
  value     Int
  createdAt DateTime @default(now())

  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([commentId, userId])
  @@index([commentId])
}

// ============ NOTIFICATION SYSTEM ============

enum NotificationType {
  COMMENT_REPLY   // Someone replied to your comment
  POST_COMMENT    // Someone commented on your post
  POST_VOTE       // Your post received significant votes
  EVENT_REMINDER  // Upcoming event reminder
  NEW_MEMBER      // Someone joined your community (owner only)
}

model Notification {
  id        String           @id @default(cuid())
  type      NotificationType
  userId    String           // Recipient
  title     String           @db.VarChar(255)
  message   String?          @db.Text
  link      String?          @db.VarChar(500) // URL to navigate to
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead, createdAt(sort: Desc)])
  @@index([userId, createdAt(sort: Desc)])
}
